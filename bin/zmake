#!/usr/bin/env python3

import hashlib
import shutil
import os
import glob
import fnmatch
import re
import sys
import argparse

parser=argparse.ArgumentParser(description=
    'Generating module files for constructing a single Makefile',
    prefix_chars='+-')

parser.add_argument('dir',action='store',nargs='?',default='.',
                   help='directory of source files (%(default)s)')
parser.add_argument('-R','--recursive',action='store_true',default=False,
                 help='combined with -b/--renew, recursively (%(default)s)')

# group_general, mutually exlusive
group_general=parser.add_mutually_exclusive_group()
group_general.add_argument('-f','--force',action='store_true',default=False,
                   help='force overwriting existing files (%(default)s)')
group_general.add_argument('-s','--skip',action='store_true',default=False,
                   help='skip any existing file (%(default)s)')

group_mk=parser.add_mutually_exclusive_group()
group_mk.add_argument('-d','--delete',action='store_true',default=False,
                 help='recursively delete all .mk files in [dir] (%(default)s)')
group_mk.add_argument('-b','--branch-only',action='store_true',default=False,
                 help='generate rules.mk for a single directory (%(default)s)')
group_mk.add_argument('-r','--root-only',action='store_true',default=False,
                 help='generate [dir]/root.mk (%(default)s)')

# group_makefile
group_makefile=parser.add_mutually_exclusive_group()
#=parser.add_argument_group('Makefile')
group_makefile.add_argument('-g','--makefile',action='store_true',default=False,
        help='generate a Makefile (%(default)s)')
#group_makefile.add_argument('-o',dest='target',action='store',default='Makefile',
        #help='output the Makefile to TARGET (%(default)s)')
target='Makefile'
group_makefile.add_argument('--renew',action='store_true',default=False,
        help='renew $(ROOT) in one Makefile, with -R, renew all (%(default)s)')



#parser.set_defaults(verbose=False)

args = parser.parse_args()

rootmk="""\
#	PROJECT-WIDE COMMON COMPILING FLAGS
CC		:=g++
CFLAGS 		:=-O3 -Wall -Drestrict=__restrict__ -DNDEBUG

CXX		:=$(CC)
CXXFLAGS	:=$(CFLAGS) -std=c++11

#       PROJECT-WIDE DEFAULT LINKING LIBRARIES AND INCLUDE DIRECTORIES
INCS		:=-iquote $(ROOT)
LIBS		:=

#       SUPPRESS LENGTHY COMMANDLINE ECHOS
QUIET           :=@

#	INTERNAL VARIABLES
OBJ		:=# .o files
DEP		:=# .d files
ASM		:=# .s files
DEPFLAGS	:=-MMD -MP# preprocessor generates .d files
ASMFLAGS	:=-S# source code commented assembly code
.SUFFIXES:

#	INTERNAL VARIABLES
OBJ		:=# .o files
DEP		:=# .d files
ASM		:=# .s files
DEPFLAGS	:=-MMD -MP# preprocessor generates .d files
ASMFLAGS	:=-S# source code commented assembly code
.SUFFIXES:

#	COLORFUL SHELL ECHO!
NONE		:=\033[00m
#	Normal colors
BLACK		:=\033[00;30m
RED		:=\033[00;31m
GREEN		:=\033[00;32m
BROWN		:=\033[00;33m
BLUE		:=\033[00;34m
MAGENTA		:=\033[00;35m
CYAN		:=\033[00;36m
GREY		:=\033[00;37m
#	Bold
B_BLACK		:=\033[01;30m
B_RED		:=\033[01;31m
B_GREEN		:=\033[01;32m
B_BROWN		:=\033[01;33m
B_BLUE		:=\033[01;34m
B_MAGENTA	:=\033[01;35m
B_CYAN		:=\033[01;36m
B_GREY		:=\033[01;37m
#	Underlined
U_BLACK		:=\033[04;30m
U_RED		:=\033[04;31m
U_GREEN		:=\033[04;32m
U_BROWN		:=\033[04;33m
U_BLUE		:=\033[04;34m
U_MAGENTA	:=\033[04;35m
U_CYAN		:=\033[04;36m
U_GREY		:=\033[04;37m
#	Blinking
BLK_BLACK	:=\033[05;30m
BLK_RED		:=\033[05;31m
BLK_GREEN	:=\033[05;32m
BLK_BROWN	:=\033[05;33m
BLK_BLUE	:=\033[05;34m
BLK_MAGENTA	:=\033[05;35m
BLK_CYAN	:=\033[05;36m
BLK_GREY	:=\033[05;37m
#	Reversed foreground and background color
REV_BLACK	:=\033[07;30m
REV_RED		:=\033[07;31m
REV_GREEN	:=\033[07;32m
REV_BROWN	:=\033[07;33m
REV_BLUE	:=\033[07;34m
REV_MAGENTA	:=\033[07;35m
REV_CYAN	:=\033[07;36m
REV_GREY	:=\033[07;37m
"""

branchmk="""\
#  THIS DIRECTORY
DIR_RANDOM_NUM:=$(ROOT)#RELATIVE_PATH_FROM_ROOT#
#  ALL C/C++ FILES IN THIS DIRECTORY (WITHOUT PATHNAME)
$(DIR_RANDOM_NUM)C:=$(wildcard *.c)
$(DIR_RANDOM_NUM)CPP:=$(wildcard *.cpp)
#  DIRECTORY-SPECIFIC COMPILING FLAGS AND INCLUDE DIRECTORIES
$(DIR_RANDOM_NUM)CFLAGS:=$(CFLAGS)
$(DIR_RANDOM_NUM)CXXFLAGS:=$(CXXFLAGS)
$(DIR_RANDOM_NUM)INCS:=$(INCS)
$(DIR_RANDOM_NUM)LIBS:=$(LIBS)

DEP+=$($(DIR_RANDOM_NUM)CPP:%.cpp=$(DIR_RANDOM_NUM)/%.d) $($(DIR_RANDOM_NUM)C:%.c=$(DIR_RANDOM_NUM)/%.d)
OBJ+=$($(DIR_RANDOM_NUM)CPP:%.cpp=$(DIR_RANDOM_NUM)/%.o) $($(DIR_RANDOM_NUM)C:%.c=$(DIR_RANDOM_NUM)/%.o)
ASM+=$($(DIR_RANDOM_NUM)CPP:%.cpp=$(DIR_RANDOM_NUM)/%.s) $($(DIR_RANDOM_NUM)C:%.c=$(DIR_RANDOM_NUM)/%.s)

$(DIR_RANDOM_NUM)/%.o: $(DIR_RANDOM_NUM)/%.c
	$(QUIET)$(CC) -o $@ -c $< $(DEPFLAGS) $($(DIR_RANDOM_NUM)CFLAGS) $($(DIR_RANDOM_NUM)INCS)
	$(QUIET)echo "Compiling $(GREEN)$(notdir $<) $(NONE)..."
$(DIR_RANDOM_NUM)/%.s: $(DIR_RANDOM_NUM)/%.c
	$(QUIET)$(CC) -o $@ $< $(ASMFLAGS) $($(DIR_RANDOM_NUM)CFLAGS) $($(DIR_RANDOM_NUM)INCS)
	$(QUIET)echo "Assembly listing $(CYAN)$(notdir $<) $(NONE)..."

$(DIR_RANDOM_NUM)/%.o: $(DIR_RANDOM_NUM)/%.cpp
	$(QUIET)$(CXX) -o $@ -c $< $(DEPFLAGS) $($(DIR_RANDOM_NUM)CXXFLAGS) $($(DIR_RANDOM_NUM)INCS)
	$(QUIET)echo "Compiling $(GREEN)$(notdir $<) $(NONE)..."
$(DIR_RANDOM_NUM)/%.s: $(DIR_RANDOM_NUM)/%.cpp
	$(QUIET)$(CXX) -o $@ $< $(ASMFLAGS) $($(DIR_RANDOM_NUM)CXXFLAGS) $($(DIR_RANDOM_NUM)INCS)
	$(QUIET)echo "Assembly listing $(CYAN)$(notdir $<) $(NONE)..."

# Linking pattern rule for this directory
%.exe: $(DIR_RANDOM_NUM)/%.o
	$(QUIET)$(CXX) -o $@ $^ $($(DIR_RANDOM_NUM)LIBS)
	$(QUIET)echo "Linking $(MAGENTA)$(notdir $@) $(NONE)..."
"""

makefile="""\
ROOT    :=$(realpath #ABSOLUTE_ROOT_OF_SOURCE_FILES#)
d       :=#ABSOLUTE_PATH_OF_CURRENT_DIRECTORY## this directory
-include $(ROOT)/root.mk
-include $(ROOT)#INCLUDE_ALL_BRANCHES_HERE#
-include $(DEP)

# List all the executables you want to run when you type `make test` in $(TESTS)
# Note that you need to -include $(ROOT)/gtest/rules.mk to actually build those
# executables
TESTS:=

.PHONY: all asm clean test
all: $(OBJ)
asm: $(ASM)
clean:
	$(QUIET)echo "\t\t\t======== CLEANUP ========"
	$(QUIET)rm -f *.exe $(OBJ) $(DEP) $(ASM)
test: $(TESTS)
	$(QUIET)echo "\t\t\t======== TESTS ========"
	$(QUIET)for t in $^ ; do ./"$$t" ; done

# Sample linking rules for building executables:
#test_heapsort.exe: $(d)/heapsort.o $(d)/test_heapsort.o $(ROOT)/utils/utils.o
#gtest_dag.exe: $(ROOT)/gtest/gtest_main.a $(d)/gtest_dag.o $(d)/dag.o
"""
texts=dict()
texts['root']=rootmk
texts['branch']=branchmk
texts['makefile']=makefile

def check_overwrite(fname):
    """warn when trying to overwrite existing file"""
    # False=overwrite, True=do not overwrite
    if os.path.isfile(fname):
        if args.skip==True:
            return True
        #elif args.force==True:
            #return False
        flag=False
        rawinput=input(' '.join([fname,
                                 'already exists, overwrite (y/n/q)? ']))
        raw=rawinput[0].lower()
        if raw=='y':
            flag=False
        elif raw=='n':
            flag=True
        elif raw=='q':
            print('abort')
            exit(1)
        else:
            print(rawinput,'does not match y/n/q, abort.')
            exit(1)
        return flag
    else:
        return False

#print(check_overwrite('/Users/qzmfrank/.vimrc'))

def strfile(fname,str):
    """create file, copy string into it"""
    fd=open(fname,'w')
    fd.write(str)
    fd.close()
    print(fname)

def strfile2(fname,str):
    """create file, copy string into it, check existing file"""
    if args.force:
        strfile(fname,str)
    elif check_overwrite(fname)==False:
        strfile(fname,str)

#strfile2('rootnew.mk',rootmk)

def find_abspath(dir):
    """return the absolute path of dir"""
    if dir[0]=='/':
        root=dir
    else:
        root=os.path.normpath(os.path.join(os.getcwd(),dir))
    return root

def find_root(dir):
    """return the absolute path of root.mk (excluding file name)"""
    flag=False
    root=find_abspath(dir)

    if os.path.isfile(os.path.join(root,'root.mk')):
        flag=True
    else:
        depth=99 #default maximal depth of search
        for i in range(depth):
            root=os.path.normpath(os.path.join(root,'..'))
            #print(root)
            if root=='/':
                if os.path.isfile('/root.mk'):
                    flag=True
                break
            else:
                if os.path.isfile(os.path.join(root,'root.mk')):
                    flag=True
                    break
    if flag:
        return root
    else:
        print('root.mk not found')
        exit(1)

#find_root(args.dir,args.max_recursive_depth)

def gen_root(root,text):
    """generate root.mk"""
    fname=os.path.join(root,'root.mk')
    strfile2(fname,text)

#gen_root(args.root,rootmk)

def gen_branch(root,path,text,files):
    """generate rules.mk"""
    c_src=fnmatch.filter(files,'*.c')
    cpp_src=fnmatch.filter(files,'*.cpp')
    if len(c_src)+len(cpp_src)<=0: return

    fname=os.path.join(path,'rules.mk')
    relative_path=path.replace(os.path.normpath(root),'')
    hashstr=hashlib.md5(relative_path.encode('utf-8')).hexdigest()
    #print(hashstr)
    tmp=text.replace('#RELATIVE_PATH_FROM_ROOT#',relative_path)
    tmp=tmp.replace('DIR_RANDOM_NUM','DIR'+hashstr)
    strfile2(fname,tmp)

def gen_branch_only(dir,text):
    """--branch-only"""
    dir=os.path.abspath(dir)
    dir=os.path.normpath(dir)
    root=find_root(dir)
    files=os.listdir(dir)
    gen_branch(root,dir,text,files)

def rwalk(dir,texts):
    """recursively rules.mk's"""
    root=find_root(dir)
    for path,dirs,files in os.walk(root):
        gen_branch(root,path,texts['branch'],files)

#rwalk(args.dir,texts)

def rwalk_skip(dir,texts):
    """recursively generate rules.mk's, skip any existing file"""
    root=find_root(dir)
    for path,dirs,files in os.walk(root):
        if os.path.isfile(os.path.join(path,'rules.mk'))==False:
            gen_branch(root,path,texts['branch'],files)
    return True


def collect_branch(root):
    """return the list of rules.mk files for generating Makefile"""
    dirlist=list()
    for path,dirs,files in os.walk(root):
        fname=os.path.join(path,'rules.mk')
        if os.path.isfile(fname):
            dirlist.append(os.path.join(path.replace(root,''),'rules.mk'))
    return dirlist


def gen_makefile(dir,target,text):
    """recursively find root.mk before generating makefile"""
    root=find_root(dir)
    relpath = os.path.relpath(dir, root)
    reldepth = re.sub('[^/]*', '..', relpath)
    tmp=text.replace('#ABSOLUTE_ROOT_OF_SOURCE_FILES#', reldepth)
    dirlist=collect_branch(root)
    tmp=tmp.replace('#INCLUDE_ALL_BRANCHES_HERE#',
                    '\n-include $(ROOT)'.join(dirlist))
    tmp=tmp.replace('#ABSOLUTE_PATH_OF_CURRENT_DIRECTORY#',
                    find_abspath(dir).replace(root,'$(ROOT)'))

    strfile2(target,tmp)

#rgen_imakefile(args.root,args.target,texts,args.max_recursive_depth)

def delete_all(dir):
    """recursively delete all .mk files"""
    #root=find_root(dir)
    for path,dirs,files in os.walk(dir):
        fname=os.path.join(path,'rules.mk')
        if os.path.isfile(fname):
            os.remove(fname)
            print('deleted',fname)
        fname=os.path.join(path,'root.mk')
        if os.path.isfile(fname):
            os.remove(fname)
            print('deleted',fname)


def replace_1stline(fname,root):
    """replace the ROOT:= line in a Makefile"""
    tmp=fname+'.orig'
    shutil.copyfile(fname,tmp)
    lines=open(tmp,'r').readlines()
    os.remove(tmp)

    # find the line containing the def of ROOT
    ln_num=0
    index=0
    for line in lines:
        index=line.find('ROOT    :=')
        if index>=0:
            break
        ln_num=ln_num+1
    lines[ln_num]=lines[ln_num][0:index]+'ROOT    :='+root+'\n'

    fout=open(fname,'w')
    fout.writelines(lines)
    fout.close()

def replace_2ndline(fname,root):
    """replace the d:= line in a Makefile"""
    tmp=fname+'.orig'
    shutil.copyfile(fname,tmp)
    lines=open(tmp,'r').readlines()
    os.remove(tmp)
    dir = os.path.dirname(fname)

    ln_num=0
    index=0
    for line in lines:
        index=line.find('d       :=')
        if index>=0:
            break
        ln_num=ln_num+1
    lines[ln_num]=lines[ln_num][0:index] \
                    +'d       :=$(ROOT)/' \
                    +os.path.relpath(dir,root) \
                    +'#this directory\n'
    fout=open(fname,'w')
    fout.writelines(lines)
    fout.close()

def renew_makefile(dir,target):
    """renew $(ROOT) in one Makefile"""
    root=find_root(dir)
    fname=os.path.join(os.path.abspath(dir),target)
    if os.path.isfile(fname):
        print(fname)
        replace_1stline(fname,root)
        replace_2ndline(fname,root)

def renew_makefiles(dir,target):
    """renew $(ROOT) in all Makefiles"""
    root=find_root(dir)
    for path,dirs,files in os.walk(root):
        fname=os.path.join(path,target)
        if os.path.isfile(fname):
            replace_1stline(fname,root)
            replace_2ndline(fname,root)

if args.delete:
    delete_all(args.dir)
    exit(0)

if args.branch_only:
    if args.recursive:
        rwalk(args.dir,texts)
    else:
        gen_branch_only(args.dir,texts['branch'])
    exit(0)

if args.root_only:
    gen_root(args.dir,texts['root'])
    exit(0)

if args.makefile:
    gen_makefile(args.dir,'Makefile',texts['makefile'])
    exit(0)

if args.renew:
    if args.recursive:
        renew_makefiles(args.dir,'Makefile')
    else:
        renew_makefile(args.dir,'Makefile')
    exit(0)
