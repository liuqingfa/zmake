#!/usr/bin/env python3


import os
import fnmatch
import sys 
import argparse

parser=argparse.ArgumentParser(description=
    'Generating module files for constructing a single Makefile',
    prefix_chars='+-')

parser.add_argument('root',action='store',nargs='?',default='.',
                   help='root directory of source files (%(default)s)')

parser.add_argument('-f','--force',action='store_true',default=False,
                    help='force overwrite (%(default)s)')

group=parser.add_mutually_exclusive_group()
group.add_argument('-u','--update',action='store_true',default=False,
                   help='skip existing .mk files (%(default)s)')
group.add_argument('-d','--delete',action='store_true',default=False,
                   help='recursively delete all root.mk and branch.mk\'s (%(default)s)')
group.add_argument('-g','--generate-makefile',action='store_true',default=False,
                   help='generate a Makefile (%(default)s)')

parser.add_argument('-o',dest='target',action='store',default='./Makefile',
                  help='output the Makefile to TARGET (%(default)s)') 
parser.add_argument('-n','--max-recursive-depth',metavar='N',type=int,default=3,
                  help='maximal depth for upwards search when creating \
                    Makefiles (%(default)s)') 

group=parser.add_mutually_exclusive_group()
group.add_argument('--in-source',dest='insource',action='store_true',default=True,
                  help='the generated Makefile uses in-source build (%(default)s)')
group.add_argument('--out-of-source',dest='insource',action='store_false',default=False,
                  help='the generated Makefile uses out-of-source build')

#parser.set_defaults(verbose=False)
args = parser.parse_args()



rootmk="""################################################################################
#	MISC PROJECT INFO
PROJECT_NAME	:=#Enter project name here#
VERSION		:=#Enter project version here#
DATE_TIME	:=$(shell date "+%Y-%m-%d")
OS		:=$(shell uname -s)
ARCH		:=$(shell uname -m)
PLATFORM	:=${OS}-${ARCH}
RELEASE_NAME	:=${PROJECT_NAME}-${PLATFORM}-${VERSION}-${DATE_TIME} 
#	PROJECT-WIDE COMMON COMPILING FLAGS 
CC		:=icc
CFLAGS 		:=-O3							\\
		-Wall							\\
		-std=c99						\\
		-Wno-deprecated

CXX		:=icpc
CXXFLAGS	:=-O3							\\
		-Wall							\\
		-Wno-deprecated

DEPFLAGS	:=-MMD -MP# preprocessor generates .d files
ASMFLAGS	:=-S -fsource-asm# source code commented assembly code

#PROJECT-WIDE DEFAULT LINKING LIBRARIES AND INCLUDE DIRECTORIES
INCS		:=-iquote ${ROOT}
LIBS		:=
################################################################################
#	MISC TARGETS 
.PHONY: clean cleanx cleanxx

clean:
	${QUIET}rm -f ${OBJ}
cleanx:
	${QUIET}rm -f ${DEP} ${ASM}
cleanxx: clean cleanx
	${QUIET}rm -f *.exe
################################################################################
#		INTERNAL VARIABLES
OBJ		:=# .o files
DEP		:=# .d files
ASM		:=# .s files
################################################################################
# 		PATTERN RULES
# Undefine GNU make default pattern rules
.SUFFIXES:
#.SUFFIXES: .c .cc .C .cpp .h .hh .hpp .o .a .dll .so .dylib .exe .d .s .S
# Default pattern rule for out-of-source linking
ifeq (${OUT_OF_SOURCE},TRUE)
%.exe: %.o
	@echo "Linking ${RED}$@${NONE}"
	${QUIET}${CXX} -o $@ $^ ${LIBS} 
endif
################################################################################
#		COLORFUL SHELL ECHO!
NONE		:=\\033[00m 
#	normal colors
BLACK		:=\\033[00;30m
RED		:=\\033[00;31m
GREEN		:=\\033[00;32m
BROWN		:=\\033[00;33m 
BLUE		:=\\033[00;34m
MAGENTA		:=\\033[00;35m
CYAN		:=\\033[00;36m
GREY		:=\\033[00;37m 
#	bold
B_BLACK		:=\\033[01;30m
B_RED		:=\\033[01;31m
B_GREEN		:=\\033[01;32m
B_BROWN		:=\\033[01;33m 
B_BLUE		:=\\033[01;34m
B_MAGENTA	:=\\033[01;35m
B_CYAN		:=\\033[01;36m
B_GREY		:=\\033[01;37m 
#	underlined
U_BLACK		:=\\033[04;30m
U_RED		:=\\033[04;31m
U_GREEN		:=\\033[04;32m
U_BROWN		:=\\033[04;33m 
U_BLUE		:=\\033[04;34m
U_MAGENTA	:=\\033[04;35m
U_CYAN		:=\\033[04;36m
U_GREY		:=\\033[04;37m 
#	blinking
BLK_BLACK	:=\\033[05;30m
BLK_RED		:=\\033[05;31m
BLK_GREEN	:=\\033[05;32m
BLK_BROWN	:=\\033[05;33m 
BLK_BLUE	:=\\033[05;34m
BLK_MAGENTA	:=\\033[05;35m
BLK_CYAN	:=\\033[05;36m
BLK_GREY	:=\\033[05;37m 
#	reversed foreground and background color
REV_BLACK	:=\\033[07;30m
REV_RED		:=\\033[07;31m
REV_GREEN	:=\\033[07;32m
REV_BROWN	:=\\033[07;33m 
REV_BLUE	:=\\033[07;34m
REV_MAGENTA	:=\\033[07;35m
REV_CYAN	:=\\033[07;36m
REV_GREY	:=\\033[07;37m 
"""

branchmk="""################################################################################
#  THIS DIRECTORY
DIR_RANDOMNUMBER:=${ROOT}#RELATIVE_PATH_FROM_ROOT#
#  ALL C/C++ FILES IN THIS DIRECTORY (WITHOUT PATHNAME)
${DIR_RANDOMNUMBER}C:=#LIST_C_SOURCE_FILES#
${DIR_RANDOMNUMBER}CPP:=#LIST_CPP_SOURCE_FILES# 
#  DIRECTORY-SPECIFIC COMPILING FLAGS AND INCLUDE DIRECTORIES
${DIR_RANDOMNUMBER}CFLAGS:=${CFLAGS}
${DIR_RANDOMNUMBER}CXXFLAGS:=${CXXFLAGS}
${DIR_RANDOMNUMBER}INCS:=${INCS}
################################################################################ 
#		INTERNAL VARIABLES AND PATTERN RULES
ifeq (${OUT_OF_SOURCE},TRUE)
# out-of-source build
# Process variables
${DIR_RANDOMNUMBER}DEP:=${${DIR_RANDOMNUMBER}CPP:%.cpp=${BUILD}/%.d} ${${DIR_RANDOMNUMBER}C:%.c=${BUILD}/%.d} 
${DIR_RANDOMNUMBER}OBJ:=${${DIR_RANDOMNUMBER}CPP:%.cpp=${BUILD}/%.o} ${${DIR_RANDOMNUMBER}C:%.c=${BUILD}/%.o} 
${DIR_RANDOMNUMBER}ASM:=${${DIR_RANDOMNUMBER}CPP:%.cpp=${BUILD}/%.s} ${${DIR_RANDOMNUMBER}C:%.c=${BUILD}/%.s} 
# Add to global variables
DEP:=${DEP} ${${DIR_RANDOMNUMBER}DEP}
OBJ:=${OBJ} ${${DIR_RANDOMNUMBER}OBJ}
ASM:=${ASM} ${${DIR_RANDOMNUMBER}ASM}
# C sources
${BUILD}/%.o: ${DIR_RANDOMNUMBER}/%.c
	@echo Compiling "${GREEN}$@${NONE}"
	${QUIET}${CC} -o $@ -c $< ${DEPFLAGS} ${${DIR_RANDOMNUMBER}CFLAGS} ${${DIR_RANDOMNUMBER}INCS}
${BUILD}/%.s: ${DIR_RANDOMNUMBER}/%.c
	@echo Compiling "${CYAN}$@${NONE}"
	${QUIET}${CC} -o $@ $< ${ASMFLAGS} ${${DIR_RANDOMNUMBER}CFLAGS} ${${DIR_RANDOMNUMBER}INCS}

# C++ sources
${BUILD}/%.o: ${DIR_RANDOMNUMBER}/%.cpp
	@echo Compiling "${GREEN}$@${NONE}"
	${QUIET}${CXX} -o $@ -c $< ${DEPFLAGS} ${${DIR_RANDOMNUMBER}CXXFLAGS} ${${DIR_RANDOMNUMBER}INCS}
${BUILD}/%.s: ${DIR_RANDOMNUMBER}/%.cpp
	@echo Compiling "${CYAN}$@${NONE}"
	${QUIET}${CXX} -o $@ $< ${ASMFLAGS} ${${DIR_RANDOMNUMBER}CXXFLAGS} ${${DIR_RANDOMNUMBER}INCS}
else
# in-place build
# Process variables
${DIR_RANDOMNUMBER}DEP:=${${DIR_RANDOMNUMBER}CPP:%.cpp=${DIR_RANDOMNUMBER}/%.d} ${${DIR_RANDOMNUMBER}C:%.c=${DIR_RANDOMNUMBER}/%.d} 
${DIR_RANDOMNUMBER}OBJ:=${${DIR_RANDOMNUMBER}CPP:%.cpp=${DIR_RANDOMNUMBER}/%.o} ${${DIR_RANDOMNUMBER}C:%.c=${DIR_RANDOMNUMBER}/%.o} 
${DIR_RANDOMNUMBER}ASM:=${${DIR_RANDOMNUMBER}CPP:%.cpp=${DIR_RANDOMNUMBER}/%.s} ${${DIR_RANDOMNUMBER}C:%.c=${DIR_RANDOMNUMBER}/%.s} 
# Add to global variables
DEP:=${DEP} ${${DIR_RANDOMNUMBER}DEP}
OBJ:=${OBJ} ${${DIR_RANDOMNUMBER}OBJ}
ASM:=${ASM} ${${DIR_RANDOMNUMBER}ASM}

# C sources
${DIR_RANDOMNUMBER}/%.o: ${DIR_RANDOMNUMBER}/%.c
	@echo Compiling "${GREEN}$@${NONE}"
	${QUIET}${CC} -o $@ -c $< ${DEPFLAGS} ${${DIR_RANDOMNUMBER}CFLAGS} ${${DIR_RANDOMNUMBER}INCS}
${DIR_RANDOMNUMBER}/%.s: ${DIR_RANDOMNUMBER}/%.c
	@echo Compiling "${CYAN}$@${NONE}"
	${QUIET}${CC} -o $@ $< ${ASMFLAGS} ${${DIR_RANDOMNUMBER}CFLAGS} ${${DIR_RANDOMNUMBER}INCS}

# C++ sources
${DIR_RANDOMNUMBER}/%.o: ${DIR_RANDOMNUMBER}/%.cpp
	@echo Compiling "${GREEN}$@${NONE}"
	${QUIET}${CXX} -o $@ -c $< ${DEPFLAGS} ${${DIR_RANDOMNUMBER}CXXFLAGS} ${${DIR_RANDOMNUMBER}INCS}
${DIR_RANDOMNUMBER}/%.s: ${DIR_RANDOMNUMBER}/%.cpp
	@echo Compiling "${CYAN}$@${NONE}"
	${QUIET}${CXX} -o $@ $< ${ASMFLAGS} ${${DIR_RANDOMNUMBER}CXXFLAGS} ${${DIR_RANDOMNUMBER}INCS}

# Linking pattern rule for this directory
%.exe: ${DIR_RANDOMNUMBER}/%.o
	@echo Linking "${RED}$@${NONE}"
	${QUIET}${CXX} -o $@ $^ ${LIBS}
endif 
"""

makefile_insource="""#  Sample Makefile for in-source build
################################################################################
#QUIET:=@# uncomment this line to silence
ROOT :=#ABSOLUTE_ROOT_OF_SOURCE_FILES#
# Include the top-level .mk file, i.e., the root.mk
-include ${ROOT}/root.mk
# Include all branches here#INCLUDE_ALL_BRANCHES_HERE#
# Then include all dependency files
-include ${DEP}
################################################################################ 
#	LIST LINKING RULES
# Sample linking rules:
# The redundancy in ${ROOT} is a must. There is no easy way around.
#test_heapsort.exe: ${ROOT}/heapsort/heapsort.o \\
	#${ROOT}/heapsort/test_heapsort.o \\
	#${ROOT}/utils/utils.o
"""

makefile_outofsource="""#  Sample Makefile for out-of-source build
################################################################################
#	ROOT LEVEL INFO - MAKEFILE SPECIFIC
OUT_OF_SOURCE:=TRUE# TRUE = out-of-source build, otherwise = in-source build
BUILD:=.# out-of-source build directory, unused in in-source build mode
# Strongly recommend only using ${BUILD}=. as it simplifies the linking rules
#QUIET:=@# uncomment this line to silence
ROOT :=#ABSOLUTE_ROOT_OF_SOURCE_FILES#
# Include the top-level .mk file, i.e., the root.mk
-include ${ROOT}/root.mk
# Include all branches here#INCLUDE_ALL_BRANCHES_HERE#
# Then include all dependency files
-include ${DEP}
################################################################################ 
#	LIST LINKING RULES
# Sample linking tules:
# If ${BUILD}==. (current directory), then we can use the following linking rule
#diffpar.exe: diffpar.o utils.o
#test_heapsort.exe: heapsort.o test_heapsort.o utils.o
# Otherwise, we need to use the following linking rule
#${BUILD}/diffpar.exe: ${BUILD}/diffpar.o ${BUILD}/utils.o
#${BUILD}/test_heapsort.exe: ${BUILD}/heapsort.o ${BUILD}/test_heapsort.o ${BUILD}/utils.o
"""

texts=dict()
texts['root']=rootmk
texts['branch']=branchmk
texts['imakefile']=makefile_insource
texts['omakefile']=makefile_outofsource

def check_overwrite(fname):
    """warn when trying to overwrite existing file"""
    if os.path.isfile(fname):
        flag=False
        rawinput=input(' '.join([fname,
            'already exists, overwrite (y/n/q)?']))
        raw=rawinput[0].lower()
        if raw=='y':
            flag=False 
        elif raw=='n':
            flag=True
        elif raw=='q': 
            exit(1)
        else:
            print(rawinput,'does not match y/n/q. Abort.')
            exit(1)
        return flag
    else:
        return False

#print(check_overwrite('/Users/qzmfrank/.vimrc'))

def strfile(fname,str):
    """create file, copy string into it""" 
    fd=open(fname,'w')
    fd.write(str)
    fd.close()

def strfile2(fname,str):
    """create file, copy string into it, check existing file"""
    if args.force:
        strfile(fname,str)
        return True
    else:
        if check_overwrite(fname)==False:
            strfile(fname,str) 
            return True
        else:
            return False

#strfile2('rootnew.mk',rootmk)

def gen_root(root,text):
    """generate root.mk"""
    fname=os.path.join(root,'root.mk')
    if strfile2(fname,text):
        print('generated',fname)

#gen_root(args.root,rootmk)

def gen_branch(root,path,text,files,num):
    """generate the num-th branch.mk"""
    c_src=fnmatch.filter(files,'*.c')
    cpp_src=fnmatch.filter(files,'*.cpp')
    if len(c_src)+len(cpp_src)>0:
        fname=os.path.join(path,'branch.mk') 
        tmp=text.replace('DIR_RANDOMNUMBER','-'.join(['DIR',str(num)]))
        tmp=tmp.replace('#RELATIVE_PATH_FROM_ROOT#',
                        path.replace(os.path.normpath(root),''))
        c_str=' '.join(c_src)
        tmp=tmp.replace('#LIST_C_SOURCE_FILES#',c_str) 
        cpp_str=' '.join(cpp_src)
        tmp=tmp.replace('#LIST_CPP_SOURCE_FILES#',cpp_str)
        if strfile2(fname,tmp): 
            print(num,'generated',fname) 

def rwalk(root,texts):
    """recursively scan and generate root.mk and branch.mk's"""
    num=10000
    gen_root(root,texts['root'])
    for path,dirs,files in os.walk(root):
        gen_branch(root,path,texts['branch'],files,num)
        num=num+1
    return True

#rwalk(args.root,texts)

def rwalk_update(root,texts):
    """recursively scan and generate root.mk and branch.mk's"""
    num=10000
    if os.path.isfile(os.path.join(root,'root.mk'))==False:
        gen_root(root,texts['root'])
    for path,dirs,files in os.walk(root): 
        if os.path.isfile(os.path.join(path,'branch.mk'))==False:
            gen_branch(root,path,texts['branch'],files,num)
        num=num+1
    return True

def gen_imakefile(absroot,target,text):
    """generate in-source makefile""" 
    tmp=text.replace('#ABSOLUTE_ROOT_OF_SOURCE_FILES#',absroot)
    dirlist=list();
    for path,dirs,files in os.walk(absroot):
        fname=os.path.join(path,'branch.mk')
        if os.path.isfile(fname):
            dirlist.append(os.path.join(path.replace(absroot,''),'branch.mk'))
    tmp=tmp.replace('#INCLUDE_ALL_BRANCHES_HERE#',
                    '\n-include ${ROOT}'.join(dirlist))
    if strfile2(target,tmp):
        print('generated',target)

#gen_imakefile(args.root,args.target,texts['imakefile'])

def gen_omakefile(absroot,target,text):
    """generate in-source makefile""" 
    tmp=text.replace('#ABSOLUTE_ROOT_OF_SOURCE_FILES#',absroot)
    dirlist=list();
    for path,dirs,files in os.walk(absroot):
        fname=os.path.join(path,'branch.mk')
        if os.path.isfile(fname):
            dirlist.append(os.path.join(path.replace(absroot,''),'branch.mk'))
    tmp=tmp.replace('#INCLUDE_ALL_BRANCHES_HERE#',
                    '\n-include ${ROOT}'.join(dirlist))
    if strfile2(target,tmp):
        print('generated',target)

#gen_omakefile(args.root,args.target,texts['imakefile'])

def rgen_makefile(insource,root,target,texts,depth):
    """recursively find root.mk before generating makefile"""
    flag=False
    absroot=os.path.join(os.getcwd(),root)
    if os.path.isfile(os.path.join(absroot,'root.mk')):
        flag=True
    else:
        for i in range(depth):
            absroot=os.path.normpath(os.path.join(absroot,'..'))
            print(absroot)
            if os.path.isfile(os.path.join(absroot,'root.mk')):
                flag=True
                break
    if flag:
        if insource:
            gen_imakefile(absroot,target,texts['imakefile'])
        else: 
            gen_omakefile(absroot,target,texts['omakefile'])
    else:
        print('root.mk not found')
    return flag

#rgen_imakefile(args.root,args.target,texts,args.max_recursive_depth)

def delete_all(root):
    """recursively delete all root.mk and branch.mk's"""
    #if os.path.isfile(
    for path,dirs,files in os.walk(root):
        fname=os.path.join(path,'branch.mk')
        if os.path.isfile(fname):
            os.remove(fname)
            print('deleted',fname)
        fname=os.path.join(path,'root.mk')
        if os.path.isfile(fname):
            os.remove(fname)
            print('deleted',fname) 

if args.delete:
    delete_all(args.root)
elif args.generate_makefile:
    rgen_makefile(args.insource,args.root,args.target,texts,args.max_recursive_depth)
elif args.update:
    rwalk_update(args.root,texts)
else:
    rwalk(args.root,texts)
